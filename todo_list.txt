сделать пример использования докер композа(чтобы хотя бы проект сам по себе мог работать)/сделать маленький проект для показа
пересмотреть тесты, мб что-то поменять
добавить тесты pkce, но потом, потому что к ним должен иметь доступ только админ
СДЕЛАНО, ОСТАВЛЯЮ НА ПАМЯТЬ реализовать PKCE(доп проверка в начале) 
  - https://habr.com/ru/companies/beget/articles/886874/ - сразу поискать PKCE.
  - сделать таблицу под пользовательские приложения
  - круды, вью и тд - мб можно будет только get post обойтись
  - скорее всего рефак всех вьюшек, сделать абстрактный класс AbstractCRUD и унаследоваться 
      от него с генериком на базовые круды и потом уже делать по отдельному классу на каждую сущность.
      Можно посмотреть в репе https://github.com/MalyshM/leetcode_plus_code_snippets/blob/main/oop/solid.py
переписать на конфиг в ямле
сделать роут, который отдает метадату о сервисе
```
https://www.rfc-editor.org/rfc/rfc8414.html#section-1.1
GET /.well-known/oauth-authorization-server HTTP/1.1
     Host: example.com

HTTP/1.1 200 OK
     Content-Type: application/json

     {
      "issuer":
        "https://server.example.com",
      "authorization_endpoint":
        "https://server.example.com/authorize",
      "token_endpoint":
        "https://server.example.com/token",
      "token_endpoint_auth_methods_supported":
        ["client_secret_basic", "private_key_jwt"],
      "token_endpoint_auth_signing_alg_values_supported":
        ["RS256", "ES256"],
      "userinfo_endpoint":
        "https://server.example.com/userinfo",
      "jwks_uri":
        "https://server.example.com/jwks.json",
      "registration_endpoint":
        "https://server.example.com/register",
      "scopes_supported":
        ["openid", "profile", "email", "address",
         "phone", "offline_access"],
      "response_types_supported":
        ["code", "code token"],
      "service_documentation":
        "http://server.example.com/service_documentation.html",
      "ui_locales_supported":
        ["en-US", "en-GB", "en-CA", "fr-FR", "fr-CA"]
     }
```
добавить oauth2, мб прям самому стать им(воссоздать, по типу IAM(https://habr.com/ru/companies/beget/articles/886874/)):
    - добавить явный флоу - когда другой бекенд логинится с кредами юзера(как сейчас)этот бекенд
        должен запоминать рефреш токен, но не отдавать его фронту
        и добавить неявный флоу - возвращаю только access_token без рефреша и на короткое время.
        На самом деле это может решиться PKCE, о нем в подзадаче задачи ниже написано
    - придумать как безопасно хранить рефреш токен на клиенте(Взаимодействия, 
        происходящие напрямую между Сервером Авторизации и клиентом по 
        доверенному каналу на бэкэнде.(https://habr.com/ru/companies/beget/articles/886874/))
        - попробовать юзать TLS - сделано в make start_tls
        - добавить Proof of Possession, DPoP либо привязку токена к 
            сертификату mTLS клиента либо PKCE - больше всего мне понравился PKCE
    - попробовать сделать чтобы запрос на обновление токена аннулировал все предыдущие токены доступа (и токены обновления).
      - вот это не совсем надо, надо удалять запись в базе про "утекший ключ" у определенного сервиса и все будет норм
    - сделать роут который банит любые токены(сброс всех токенов(ротация)/инвалидация токена)
      - инвалидация мне нравится, но это делается чем-то по типу nginx с защитой от дудоса/нужна таблица 
        с неправильными попытками входа подряд и бизнес логика поверх этого всего
    - добавить возможность добавления конфига "доверенных приложений", эти токены должны быть валидны только во внутренней сети
посмотреть IAM, изучить его, попытаться воссоздать
добавить многофакторную аутентификацию(почта, мб телефон)
добавить возможность настройки прав доступа(другая таблица, связь один юзер - много ролей), 
    в зависимости от этих прав надо ограничивать доступ(например доступ юзер может изменять 
    и удалять только свой id, не может добавлять пользователей и тд.). это политики авторизации
добавить скоупы - куда клиент может ходить с токеном(юзер может выбрать часть своих прав и передать клиенту)
базово готово - сделать ui на fastui/flatter
добавить конфиг параметров запуска с gunicorn
Concurrent Token Refresh - реализовать через линеаризуемые атомарные операции кафки 
    - это уже выходит за рамки микросервиса и мб это надо делать уже в "экосистеме" микросервиса
флоу авторизации устройства - если совсем делать нечего в новом роуте - клиент просит qr_code 
    - юзер заходит в браузер по qr-коду и его просят написать код для входа на девайсе
    - после того как код ввели - девайс авторизируется